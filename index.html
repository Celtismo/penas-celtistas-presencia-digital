<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8">
  <title>Presencia digital de las peñas celtistas</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Datos públicos sobre la presencia en internet y redes sociales de las peñas celtistas.">
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 24px; max-width: 1200px; }
    h1 { margin: 0 0 6px; }
    .meta { font-size: 14px; opacity: .8; margin: 0 0 12px; }
    .bar { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; margin: 12px 0; }
    input { padding: 8px 10px; font-size: 14px; min-width: 280px; }
    .pill { border: 1px solid #ccc; border-radius: 999px; padding: 2px 8px; font-size: 12px; }
    table { width: 100%; border-collapse: collapse; margin-top: 8px; table-layout: fixed; }

    th, td {
      border-bottom: 1px solid #e5e5e5;
      padding: 8px 6px;
      vertical-align: top;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    th { cursor: pointer; background: #fafafa; position: sticky; top: 0; user-select: none; }
    th small { opacity: .5; margin-left: 4px; }
    tr:hover td { background: #f9f9f9; }

    a { color: inherit; text-decoration: underline; text-underline-offset: 2px; }

    th.col-pena, td.col-pena { width: 260px; text-align: left; }
    th.col-web,  td.col-web  { width: 70px;  text-align: center; }
    th.col-net,  td.col-net  { width: 110px; text-align: right; }

    .wrap { word-break: break-word; }
  </style>
</head>
<body>

<h1>Presencia digital de las peñas celtistas</h1>
<div class="meta">
  Dataset informativo basado únicamente en datos públicos. No es un listado oficial ni un ranking de importancia.
</div>

<div class="bar">
  <input id="q" type="search" placeholder="Buscar peña, usuario o URL…">
  <span id="count" class="pill">0 filas</span>
  <span class="meta">CSV: <a id="csvLink" href="#">abrir</a></span>
  <span id="updated" class="meta"></span>
</div>

<table>
  <thead>
    <tr id="hdr"></tr>
  </thead>
  <tbody id="body"></tbody>
</table>

<script>
/* ================= CONFIG ================= */
const CSV_FILE = "penas-celtistas-rrss.csv";

const WANTED_COLS = [
  "Peñas",
  "web",
  "X",
  "Instagram",
  "Facebook",
  "Youtube",
  "TikTok",
  "Bluesky",
  "Feeberse" // en tu CSV aparece como "Feeberse"
];

const COL_LABELS = {
  "Peñas": "Peñas",
  "web": "Web",
  "X": "X",
  "Instagram": "Instagram",
  "Facebook": "Facebook",
  "Youtube": "YouTube",
  "TikTok": "TikTok",
  "Bluesky": "Bluesky",
  "Feeberse": "Feebers"
};

/* ================= DOM ================= */
const q = document.getElementById("q");
const hdr = document.getElementById("hdr");
const body = document.getElementById("body");
const count = document.getElementById("count");
const csvLink = document.getElementById("csvLink");
const updated = document.getElementById("updated");
csvLink.href = CSV_FILE;

/* ================= STATE ================= */
let rows = [];
let cols = [];
let sortCol = "Peñas";
let sortDir = 1;

// Cabeceras reales del CSV y “columna siguiente” (usuario/url) por cada red
let rawHeader = [];
const nextColMap = {}; // p.ej. nextColMap["X"] = "Unnamed: 5"

/* ================= UTILS ================= */
function stripBOM(s){ return s.replace(/^\uFEFF/, ""); }

function parseCSV(text){
  const lines = text.split(/\r?\n/).filter(l => l.trim() !== "");
  const header = stripBOM(lines[0]).split(";").map(h => h.trim());
  const data = lines.slice(1).map(line => {
    const parts = line.split(";");
    const o = {};
    header.forEach((h,i) => o[h] = (parts[i] || "").trim());
    return o;
  });
  return { header, data };
}

function isUrl(v){
  const s = String(v ?? "").trim();
  return s.startsWith("http://") || s.startsWith("https://");
}

function cleanHandle(v){
  return String(v ?? "").trim().replace(/^@/, "");
}

function isNum(v){
  const s = String(v ?? "").trim();
  if (s === "" || s === "0") return false;
  const n = Number(s.replace(/\./g,"").replace(/,/g,""));
  return Number.isFinite(n);
}

const NF = new Intl.NumberFormat("es-ES", { useGrouping: true });

function formatNum(v){
  const s = String(v ?? "").trim();
  const n = Number(s.replace(/\./g,"").replace(/,/g,""));
  return Number.isFinite(n) ? NF.format(n) : s;
}

function colClass(c){
  if (c === "Peñas") return "col-pena";
  if (c === "web") return "col-web";
  return "col-net";
}

function buildNextColMap() {
  nextColMap["web"] = null;
  for (const c of WANTED_COLS) {
    const idx = rawHeader.indexOf(c);
    if (idx >= 0 && idx + 1 < rawHeader.length) {
      nextColMap[c] = rawHeader[idx + 1]; // suele ser Unnamed: x
    } else {
      nextColMap[c] = null;
    }
  }
}

function linkFor(row, col){
  const nextKey = nextColMap[col];
  const extra = nextKey ? String(row[nextKey] || "").trim() : "";

  // Web: si extra es URL -> enlazar OK
  if (col === "web") {
    if (isUrl(extra)) return extra;
    return null;
  }

  // Si extra ya es URL, úsala
  if (isUrl(extra)) return extra;

  // Si extra es usuario/handle, construimos URL según red
  const h = cleanHandle(extra);
  if (!h) return null;

  if (col === "X") return `https://x.com/${encodeURIComponent(h)}`;
  if (col === "Instagram") return `https://www.instagram.com/${encodeURIComponent(h)}/`;
  if (col === "TikTok") return `https://www.tiktok.com/@${encodeURIComponent(h)}`;
  if (col === "Bluesky") return `https://bsky.app/profile/${encodeURIComponent(h)}`;

  // Facebook/Youtube/Feebers: si no viene URL, no inventamos
  return null;
}

function renderCell(row, col){
  const raw = String(row[col] || "").trim();
  if (!raw || raw === "0") return "";

  // Web: OK clicable si hay URL
  if (col === "web") {
    const url = linkFor(row, col);
    if (raw.toUpperCase() === "OK" && url) {
      return `<a href="${url}" target="_blank" rel="noopener noreferrer nofollow">OK</a>`;
    }
    return raw.toUpperCase() === "OK" ? "OK" : raw;
  }

  // Redes: número clicable si hay link
  if (isNum(raw)) {
    const label = formatNum(raw);
    const url = linkFor(row, col);
    if (url) {
      return `<a href="${url}" target="_blank" rel="noopener noreferrer nofollow">${label}</a>`;
    }
    return label;
  }

  // Texto no numérico (raro en redes): si es URL -> enlace
  if (isUrl(raw)) {
    return `<a class="wrap" href="${raw}" target="_blank" rel="noopener noreferrer nofollow">enlace</a>`;
  }

  return `<span class="wrap">${raw.replace(/</g,"&lt;").replace(/>/g,"&gt;")}</span>`;
}

/* ================= RENDER ================= */
function renderHeader(){
  hdr.innerHTML = "";
  cols.forEach(c => {
    const th = document.createElement("th");
    th.classList.add(colClass(c));
    th.innerHTML = `${COL_LABELS[c] || c}<small>↕</small>`;
    th.onclick = () => {
      sortDir = (sortCol === c) ? -sortDir : 1;
      sortCol = c;
      render();
    };
    hdr.appendChild(th);
  });
}

function render(){
  const term = q.value.toLowerCase();

  let list = rows.filter(r =>
    cols.some(c => String(r[c] || "").toLowerCase().includes(term)) ||
    // también busca en la columna "siguiente" (usuario/url) si existe
    cols.some(c => {
      const nk = nextColMap[c];
      return nk ? String(r[nk] || "").toLowerCase().includes(term) : false;
    })
  );

  list = list.slice().sort((a,b) => {
    const av = String(a[sortCol] || "").trim();
    const bv = String(b[sortCol] || "").trim();

    if (isNum(av) && isNum(bv)) {
      const an = Number(av.replace(/\./g,"").replace(/,/g,""));
      const bn = Number(bv.replace(/\./g,"").replace(/,/g,""));
      return (an - bn) * sortDir;
    }
    return av.localeCompare(bv, "es", { sensitivity: "base" }) * sortDir;
  });

  body.innerHTML = "";
  list.forEach(r => {
    const tr = document.createElement("tr");
    cols.forEach(c => {
      const td = document.createElement("td");
      td.classList.add(colClass(c));
      td.innerHTML = renderCell(r, c);
      tr.appendChild(td);
    });
    body.appendChild(tr);
  });

  count.textContent = `${list.length} filas`;

  // fecha arriba (si existe)
  const fc = "fecha_actualizacion";
  if (rows.length && (fc in rows[0])) {
    const freq = {};
    list.forEach(r => {
      const d = String(r[fc] || "").trim();
      if (d) freq[d] = (freq[d] || 0) + 1;
    });
    const top = Object.entries(freq).sort((a,b)=>b[1]-a[1])[0];
    updated.textContent = top ? `Última actualización: ${top[0]}` : "";
  }
}

/* ================= LOAD ================= */
async function load(){
  const res = await fetch(CSV_FILE, { cache: "no-store" });
  if (!res.ok) {
    updated.textContent = "No se pudo cargar el CSV.";
    return;
  }
  const text = await res.text();
  const parsed = parseCSV(text);

  rawHeader = parsed.header;
  buildNextColMap();

  cols = WANTED_COLS.filter(c => rawHeader.includes(c));
  rows = parsed.data;

  renderHeader();
  render();
}

q.addEventListener("input", render);
load();
</script>

</body>
</html>
