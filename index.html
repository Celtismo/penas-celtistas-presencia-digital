<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8">
  <title>Presencia digital de las peñas celtistas</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Datos públicos sobre la presencia en internet y redes sociales de las peñas celtistas.">
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 24px; max-width: 1250px; }
    h1 { margin: 0 0 6px; }
    .meta { font-size: 14px; opacity: .8; margin: 0 0 12px; }
    .bar { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; margin: 12px 0; }
    input { padding: 8px 10px; font-size: 14px; min-width: 300px; }
    .pill { border: 1px solid #ccc; border-radius: 999px; padding: 2px 8px; font-size: 12px; }

    table { width: 100%; border-collapse: collapse; margin-top: 8px; table-layout: fixed; }
    th, td {
      border-bottom: 1px solid #e5e5e5;
      padding: 8px 6px;
      vertical-align: top;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    th { cursor: pointer; background: #fafafa; position: sticky; top: 0; user-select: none; }
    th small { opacity: .5; margin-left: 4px; }
    tr:hover td { background: #f9f9f9; }

    a { color: inherit; text-decoration: underline; text-underline-offset: 2px; }

    th.col-total, td.col-total { width: 110px; text-align: right; }
    th.col-pena,  td.col-pena  { width: 300px; text-align: left; }
    th.col-web,   td.col-web   { width: 70px;  text-align: center; }
    th.col-net,   td.col-net   { width: 110px; text-align: right; }

    .wrap { word-break: break-word; }
  </style>
</head>
<body>

<h1>Presencia digital de las peñas celtistas</h1>
<div class="meta">
  Dataset informativo basado únicamente en datos públicos. No es un listado oficial ni un ranking de importancia.
</div>

<div class="bar">
  <input id="q" type="search" placeholder="Buscar peña, usuario o URL…">
  <span id="count" class="pill">0 filas</span>
  <span class="meta">CSV: <a id="csvLink" href="#">abrir</a></span>
  <span id="updated" class="meta"></span>
</div>

<table>
  <thead><tr id="hdr"></tr></thead>
  <tbody id="body"></tbody>
</table>

<script>
/* ================= CONFIG ================= */
const CSV_FILE = "penas-celtistas-rrss.csv";

/**
 * Buscamos columnas por "sinónimos" para hacer el HTML robusto
 * aunque el CSV tenga pequeñas variaciones de nombre.
 */
const COL_SYNONYMS = {
  total:   ["Total_rrss", "Total", "Total_RRSS", "Total_rrss_visible", "Total_seguidores_rrss"],
  pena:    ["Peñas", "Penas", "Peña", "Pena"],
  web:     ["web", "Web"],
  x:       ["X", "x"],
  insta:   ["Instagram", "Insta", "insta"],
  fb:      ["Facebook", "FaceB", "Face", "fb", "FB"],
  yt:      ["Youtube", "YouTube", "Youtb", "YT"],
  tt:      ["TikTok", "Tiktok", "TT"],
  bsky:    ["Bluesky", "BlueSky", "Blue"],
  feeb:    ["Feeberse", "Feebers"]
};

// Orden de columnas en pantalla (Total primero)
const DISPLAY_ORDER = ["total", "pena", "web", "x", "insta", "fb", "yt", "tt", "bsky", "feeb"];

// Etiquetas en cabecera (solo texto)
const LABELS = {
  total: "Total",
  pena: "Peñas",
  web: "Web",
  x: "X",
  insta: "Instagram",
  fb: "Facebook",
  yt: "YouTube",
  tt: "TikTok",
  bsky: "Bluesky",
  feeb: "Feebers"
};

/* ================= DOM ================= */
const q = document.getElementById("q");
const hdr = document.getElementById("hdr");
const body = document.getElementById("body");
const count = document.getElementById("count");
const csvLink = document.getElementById("csvLink");
const updated = document.getElementById("updated");
csvLink.href = CSV_FILE;

/* ================= STATE ================= */
let rows = [];
let rawHeader = [];
let colKey = {};       // canonical -> actual header key
let nextKey = {};      // canonical -> "siguiente columna" (usuario/url) si aplica
let visibleCols = [];  // canonical list (subset of DISPLAY_ORDER)
let sortCol = "pena";  // por defecto alfabético
let sortDir = 1;

/* ================= UTILS ================= */
function stripBOM(s){ return s.replace(/^\uFEFF/, ""); }

function parseCSV(text){
  const lines = text.split(/\r?\n/).filter(l => l.trim() !== "");
  const header = stripBOM(lines[0]).split(";").map(h => h.trim());
  const data = lines.slice(1).map(line => {
    const parts = line.split(";");
    const o = {};
    header.forEach((h,i) => o[h] = (parts[i] || "").trim());
    return o;
  });
  return { header, data };
}

function pickHeaderKey(header, candidates){
  for (const c of candidates) {
    if (header.includes(c)) return c;
  }
  return null;
}

function isUrl(v){
  const s = String(v ?? "").trim();
  return s.startsWith("http://") || s.startsWith("https://");
}

function cleanHandle(v){
  return String(v ?? "").trim().replace(/^@/, "");
}

function isNum(v){
  const s = String(v ?? "").trim();
  if (s === "" || s === "0") return false;
  const n = Number(s.replace(/\./g,"").replace(/,/g,""));
  return Number.isFinite(n);
}

const NF = new Intl.NumberFormat("es-ES", { useGrouping: true });

function formatNum(v){
  const s = String(v ?? "").trim();
  const n = Number(s.replace(/\./g,"").replace(/,/g,""));
  return Number.isFinite(n) ? NF.format(n) : s;
}

function colClass(canon){
  if (canon === "total") return "col-total";
  if (canon === "pena") return "col-pena";
  if (canon === "web") return "col-web";
  return "col-net";
}

/**
 * Construye enlace de perfil a partir del valor "extra" (columna siguiente)
 * - Si extra es URL: se usa tal cual
 * - Si extra es usuario:
 *    - X/Instagram/TikTok/Bluesky: construimos URL
 *    - Facebook/YouTube/Feebers: NO inventamos (solo si viene URL)
 */
function profileLinkFor(canon, extra){
  const e = String(extra ?? "").trim();
  if (!e) return null;
  if (isUrl(e)) return e;

  const h = cleanHandle(e);
  if (!h) return null;

  if (canon === "x")     return `https://x.com/${encodeURIComponent(h)}`;
  if (canon === "insta") return `https://www.instagram.com/${encodeURIComponent(h)}/`;
  if (canon === "tt")    return `https://www.tiktok.com/@${encodeURIComponent(h)}`;
  if (canon === "bsky")  return `https://bsky.app/profile/${encodeURIComponent(h)}`;

  return null;
}

/* ================= BUILD COLUMN MAPS ================= */
function buildColumnMaps(){
  // localizar claves reales
  for (const canon of Object.keys(COL_SYNONYMS)) {
    colKey[canon] = pickHeaderKey(rawHeader, COL_SYNONYMS[canon]);
  }

  // columnas visibles según existan realmente
  visibleCols = DISPLAY_ORDER.filter(c => colKey[c]);

  // mapear "columna siguiente" para enlazar (web y rrss)
  for (const canon of visibleCols) {
    nextKey[canon] = null;
    const key = colKey[canon];
    const idx = rawHeader.indexOf(key);
    if (idx >= 0 && idx + 1 < rawHeader.length) {
      nextKey[canon] = rawHeader[idx + 1];
    }
  }

  // Total y Peñas no necesitan next
  nextKey["total"] = null;
  nextKey["pena"] = null;
}

/* ================= RENDER CELL ================= */
function renderCell(row, canon){
  const key = colKey[canon];
  const raw = String(row[key] ?? "").trim();
  if (!raw || raw === "0") return "";

  // Total: solo número formateado, sin enlace
  if (canon === "total") {
    return isNum(raw) ? formatNum(raw) : raw;
  }

  // Peñas: texto
  if (canon === "pena") {
    return `<span class="wrap">${raw.replace(/</g,"&lt;").replace(/>/g,"&gt;")}</span>`;
  }

  // Web: OK clicable si hay URL en columna siguiente
  if (canon === "web") {
    const extra = nextKey[canon] ? row[nextKey[canon]] : "";
    const url = isUrl(extra) ? String(extra).trim() : null;
    if (raw.toUpperCase() === "OK" && url) {
      return `<a href="${url}" target="_blank" rel="noopener noreferrer nofollow">OK</a>`;
    }
    return raw.toUpperCase() === "OK" ? "OK" : raw;
  }

  // RRSS: si es número -> mostrar formateado; enlazar al perfil si existe
  if (isNum(raw)) {
    const label = formatNum(raw);
    const extra = nextKey[canon] ? row[nextKey[canon]] : "";
    const url = profileLinkFor(canon, extra);
    if (url) {
      return `<a href="${url}" target="_blank" rel="noopener noreferrer nofollow">${label}</a>`;
    }
    return label;
  }

  // Si llega URL directamente
  if (isUrl(raw)) {
    return `<a class="wrap" href="${raw}" target="_blank" rel="noopener noreferrer nofollow">enlace</a>`;
  }

  // Texto raro
  return `<span class="wrap">${raw.replace(/</g,"&lt;").replace(/>/g,"&gt;")}</span>`;
}

/* ================= RENDER TABLE ================= */
function renderHeader(){
  hdr.innerHTML = "";
  visibleCols.forEach(canon => {
    const th = document.createElement("th");
    th.classList.add(colClass(canon));
    th.innerHTML = `${LABELS[canon] || canon}<small>↕</small>`;
    th.onclick = () => {
      sortDir = (sortCol === canon) ? -sortDir : 1;
      sortCol = canon;
      render();
    };
    hdr.appendChild(th);
  });
}

function render(){
  const term = q.value.toLowerCase();

  let list = rows.filter(r => {
    // busca en columnas visibles y en sus "columnas siguientes" (usuario/url)
    for (const canon of visibleCols) {
      const k = colKey[canon];
      if (String(r[k] || "").toLowerCase().includes(term)) return true;
      const nk = nextKey[canon];
      if (nk && String(r[nk] || "").toLowerCase().includes(term)) return true;
    }
    return false;
  });

  list = list.slice().sort((a,b) => {
    const ak = colKey[sortCol];
    const bk = colKey[sortCol];
    const av = String(a[ak] || "").trim();
    const bv = String(b[bk] || "").trim();

    if (isNum(av) && isNum(bv)) {
      const an = Number(av.replace(/\./g,"").replace(/,/g,""));
      const bn = Number(bv.replace(/\./g,"").replace(/,/g,""));
      return (an - bn) * sortDir;
    }
    return av.localeCompare(bv, "es", { sensitivity: "base" }) * sortDir;
  });

  body.innerHTML = "";
  list.forEach(r => {
    const tr = document.createElement("tr");
    visibleCols.forEach(canon => {
      const td = document.createElement("td");
      td.classList.add(colClass(canon));
      td.innerHTML = renderCell(r, canon);
      tr.appendChild(td);
    });
    body.appendChild(tr);
  });

  count.textContent = `${list.length} filas`;

  const fc = "fecha_actualizacion";
  if (rows.length && (fc in rows[0])) {
    const freq = {};
    list.forEach(r => {
      const d = String(r[fc] || "").trim();
      if (d) freq[d] = (freq[d] || 0) + 1;
    });
    const top = Object.entries(freq).sort((a,b)=>b[1]-a[1])[0];
    updated.textContent = top ? `Última actualización: ${top[0]}` : "";
  }
}

/* ================= LOAD ================= */
async function load(){
  const res = await fetch(CSV_FILE, { cache: "no-store" });
  if (!res.ok) {
    updated.textContent = "No se pudo cargar el CSV.";
    return;
  }
  const text = await res.text();
  const parsed = parseCSV(text);

  rawHeader = parsed.header;
  rows = parsed.data;

  buildColumnMaps();
  renderHeader();
  render();
}

q.addEventListener("input", render);
load();
</script>

</body>
</html>
